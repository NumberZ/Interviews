关键在于回溯.
1.笨方法: 生成所有的排列然后找到符合条件的. 缺点: 计算量太大
2.耍小聪明:
```js
    const table =[0,1,2,3,8,10,36,41,132,250,700,750,4010,4237,10680,24679]
    function countArrangement(N) {
        return table[N];
    }
};
```

适合的解法的关键点:
1.循环加递归遍历所有的组合
2.visited数组为访问过的标记数组
3.pos为放前的下标, i为pos位置上的数字
